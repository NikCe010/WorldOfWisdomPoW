# World Of Wisdom

### Установка и запуск:<br>
    docker-compose up --build
Команда поднимет контейнер с сервером и клиентом. Настроил достаточно подробные логи, так что можно полистать логи 
контейнеров, чтобы удостоверится, что все работает. 

# Решения: <br>
### Proof of Work:
Для реализации Proof of Work был выбран [Hashcash](https://en.wikipedia.org/wiki/Hashcash). <br>
Плюсы:
- Достаточно понятный алгоритм работы
- Кастомизируемая сложность
- Изначально разработан для защиты от DDOS 
- Используется в bitcoin

### Протокол:
Протокол бинарный. 
Передает данные в формате Operation.Complexity.Length.Content. Первые 3 байта хранят в себе 
информацию о текущей стадии, размере контента и сложности задачи. Остальные байты хранят контент. Хранение длины 
контента отдельно позволяет вычитывать данные из соединения с максимально точным размером буфера. <br>
Протокол содержит <b>4 стадии</b>:
- Initiate - клиент инициирует запрос и запрашивает у сервера задачу
- SendChallenge - сервер отправляет задачу клиенту 
- SendNonce - клиент вычислил решение и отправляет ответ серверу
- SendData  - сервер проверил решение и отправляет данные 

#### Другие варианты реализации протокола:
1) Передача текущей стадии коммуникации + контент, то есть [1 0033026578], где 1 - это стадия и 0033026578 - challenge. <br>
Минусы:
   - Не знаем точный размер контента и выделяем большой буфер для вычитывания
   - Парсим каждый раз контент, чтобы понять какая сложность
   - Возможны ситуации, когда сложность будет вычислена неправильно (первый байт контента = 0)
2) Текстовый протокол. <br>
Минусы:
    - Передача большого количества байт по сети засчет строковых статусов и прочего
    - Работа со строками менее эффективная


### Получение случайной цитаты
Реализовал через мапу, в которую при инициализации закидывается 20 цитат. 
При вызове метода выбирается случайный номер и по нему достается цитата. <br> 
Плюсы: 
- Константая скорость получения элементов
- Если добавить метод добавления новой цитаты, то вполне рабочее решение

Альтернативы: 
- Складывать в массив строк и рандомить индекс 
- Читать из файла
- Прикрутить полноценную бд

### Логирование
Для логирования решил использовать log/slog. Вместе с релизом Go 1.21 появился втроенный логер с поддержкой уровней 
(Info, Warn, Error, Debug и тд), поэтому решил, что надо попробовать. Изначально использовал самописную обертку
над дефолтным логером (log), чтобы добавить уровни логирования. 

### Timeouts 
Для вычисления рекомендуемых таймаутов провел по 30 запусков. Посчитал медианное значения и максимальные значения. 
Таймаут на 20-25% выше максимальных значений.  

| Complexity | Mean Time | Max time | Recommended timeout |
|:-----------|:---------:|---------:|--------------------:|
| 2          |   70ms    |    135ms |               150ms |
| 3          |  4700ms   |   8100ms |             10000ms |

Есть отдельный таймаут на SolveChallenge метод Сейчас равен таймауту запроса. 
